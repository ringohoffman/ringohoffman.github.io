[{"categories":["Python"],"content":"Disambiguating Python and its runtime and static type systems with definitions and examples.","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/"},{"categories":["Python"],"content":" Background and MotivationI recently had a conversation with a few of my colleagues where I had mentioned that Python is a strongly typed language. One of them didn’t think that it was, and another explained that strong typing means that every object has a type, which is true about Python but is not the definition of strong typing. It surprised me to realize that even though my colleagues and I are experienced Python developers, none of us had a clear understanding of strong typing. This inspired me to write this post to help disambiguate Python and its runtime and static type systems. ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:1:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#background-and-motivation"},{"categories":["Python"],"content":" Compiled vs. Interpreted LanguagesA language itself is neither compiled nor interpreted. The terms “interpreted language” or “compiled language” signify that the canonical implementation of that language is an interpreter or a compiler, respectively. While interpretation and compilation are the two main means by which programming languages are implemented, they are not mutually exclusive, as most interpreting systems also perform some translation work, just like compilers. [1] Compiled language implementations use a compiler to translate a program’s source code to the instructions of a target machine (machine code). For example, a + operation in source code could be compiled directly to the machine code ADD instruction. [2] Interpreted language implementations use an interpreter to directly execute instructions without requiring them to have been compiled to machine code. An interpreter generally uses one of the following strategies for program execution: Parse the source code and perform its behavior directly. (Early versions of Lisp and BASIC) Translate source code into some efficient intermediate representation or object code and immediately execute that. (Python, Perl, MATLAB, and Ruby) Explicitly execute stored precompiled bytecode made by a compiler and matched with the interpreter Virtual Machine. (UCSD Pascal) Some implementations may also combine two and three, such as contemporary versions of Java. [1] Python has both compiled and interpreted implementations. CPython, Python’s reference implementation, can be defined as both an interpreter and a compiler, as it compiles Python code into bytecode before interpreting it. [3] PyPy, another Python implementation, is a just-in-time (JIT) compiler that compiles Python code into machine code at runtime. ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:2:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#compiled-vs-interpreted-languages"},{"categories":["Python"],"content":" Dynamic vs. Static TypingIn statically typed languages, variables have declared or inferred types, and a variable’s type cannot change. In dynamically typed languages like Python, values (runtime objects) have types, and variables are free to be reassigned to values of different types: [4] a = 42 a = \"hello world!\" ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:3:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#dynamic-vs-static-typing"},{"categories":["Python"],"content":" Strong vs. Weak TypingThere is no precise technical definition of what the “strength” of a type system means, [5] but for dynamically typed languages, it is generally used to refer to how primitives and library functions respond to different types. Python is considered strongly typed since most type changes require explicit conversions. A string containing only digits doesn’t magically become a number, as in JavaScript (a weakly typed language): \u003e\u003e\u003e \"1\" + 10 \"110\" In Python, + works on two numbers or two strings, but not a number and a string. This was a design choice made when + was implemented for these classes and not a necessity following from Python’s semantics. Observe that even though strongly typed, Python is completely fine with adding objects of type int and float and returns an object of type float (e.g., int(42) + float(1) returns 43.0), and when you implement + for a custom type, you can implicitly convert anything to a number. [4] ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:4:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#strong-vs-weak-typing"},{"categories":["Python"],"content":" Nominal vs. Structural TypingNominal typing is a static typing system that determines type compatibility and equivalence by explicit declarations and/or name matching. This means two variables are type-compatible if their declarations name the same type. [6] In general, Python’s static type system is nominally typed: def add_ints(a: int, b: int) -\u003e int: return a + b add_ints(1, 1) # OK add_ints(1.0, 1.0) # static typing error: \"float\" is not a subtype of \"int\" Abstract base classes (see abc) allow you to define interfaces via inheritance, i.e. nominally. A class is abstract if it inherits from abc.ABC or its metaclass is abc.ABCMeta and it has at least one abstract method (a method decorated by abc.abstractmethod). All abstract methods must be implemented by a subclass in order for that subclass to be concrete (instantiable). abc.ABC.register allows you to register an abstract base class as a “virtual superclass” of an arbitrary type. This allows virtual subclasses to pass runtime type checks like isinstance and issubclass, but has no effect on static type compatibility: import abc class MyTuple(abc.ABC): @abc.abstractmethod def something_special(self) -\u003e None: ... MyTuple.register(tuple) assert issubclass(tuple, MyTuple) # OK def do_something(obj: MyTuple) -\u003e None: ... do_something((1, 2, 3)) # static typing error: \"tuple\" is incompatible with \"MyABC\" Structural typing is a static typing system that determines type compatibility and equivalence by the type’s actual structure or definition. [7] collections.abc.Iterable is an example of a structural type in Python. It accepts any type that implements the __iter__ method. from collections.abc import Iterable, Iterator def add_numbers(numbers: Iterable[int]) -\u003e int: return sum(n for n in numbers) class MyIterable: def __iter__(self) -\u003e Iterator[int]: return iter([0, 1, 2]) add_numbers([0, 1, 2]) # OK add_numbers((0, 1, 2)) # OK add_numbers({0, 1, 2}) # OK add_numbers(range(3)) # OK add_numbers(MyIterable()) # OK add_numbers(1) # static typing error: \"__iter__\" is not present add_numbers(\"012\") # static typing error: \"str\" is not a subtype of \"int\" collections.abc provides a set of common abstract base classes that are useful for typing function parameters based on the operations performed on them, namely: operation magic method ... in x __contains__ for ... in x __iter__ next(x) __next__ reversed(x) __reversed__ len(x) __len__ x(...) __call__ x[...] __getitem__ x[...] = ... __setitem__ del x[...] __delitem__ hash(x) __hash__ Similar to abc.ABC, subclasses of collections.abc classes are nominally typed, which limits their usefulness for static typing. typing.Protocol provides a way to define custom structural types in Python. Any class that defines the same attributes and methods as a Protocol is considered to be a subtype of that Protocol: from typing import Protocol class HasName(Protocol): name: str class Person: def __init__(self, name: str) -\u003e None: self.name = name class Place: def __init__(self, name: str) -\u003e None: self.name = name def print_name(obj: HasName) -\u003e None: print(obj.name) print_name(Person(\"Matthew\")) # OK print_name(Place(\"San Francisco\")) # OK print_name(\"Austin\") # static typing error: \"name\" is not present Protocol is a special type of ABC. Its metaclass is _ProtocolMeta, a subclass of ABCMeta, and so it can be used as a drop-in replacement for ABC with one caveat: Protocol classes cannot inherit from non-Protocol classes. import abc from typing import Any, Protocol class Module: def forward(self) -\u003e Any: raise NotImplementedError(\"forward not implemented.\") class MyModuleABC(abc.ABC, Module): # OK @abc.abstractmethod def my_method(self) -\u003e None: ... class MyModuleProtocol(Protocol, Module): # TypeError: Protocols can only inherit from other protocols, got \u003cclass 'Module'\u003e @abc.abstractmethod def my_method(self) -\u003e None: ... While Protocols do not require the use of inheritance, inheritance can still be used to provide default implementations of methods or","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:5:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#nominal-vs-structural-typing"},{"categories":["Python"],"content":" Duck TypingPython’s runtime type system is duck typed. Duck typing is similar to structural typing but differs in that: Duck typing is a dynamic typing system. Compatibility is determined by checking only the parts of a type’s structure that are accessed at runtime. It gets its name from the duck test: [8] Duck test If it walks like a duck and it quacks like a duck, then it must be a duck. class Duck: def walk(self): ... def quack(self): ... def fly(self): ... duck = Duck() class Person: def walk(self): ... def quack(self): ... person = Person() def do_duck_stuff(obj): obj.walk() obj.quack() do_duck_stuff(duck) do_duck_stuff(person) # works, a \"Person\" can walk and quack like a \"Duck\"! def go_flying(obj): obj.fly() go_flying(duck) go_flying(person) # AttributeError: \"Person\" object has no attribute \"fly\" Protocols are a natural complement to duck typing since neither use inheritance to determine type compatibility. In our example above, we could define and use: from typing import Protocol class CanWalkAndQuack(Protocol): def walk(self): ... def quack(self): ... def do_duck_stuff(obj: CanWalkAndQuack) -\u003e None: obj.walk() obj.quack() do_duck_stuff(duck) # OK do_duck_stuff(person) # OK class CanFly(Protocol): def fly(self): ... def go_flying(obj: CanFly) -\u003e None: obj.fly() go_flying(duck) # OK go_flying(person) # static typing error: \"fly\" is not present ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:6:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#duck-typing"},{"categories":["Python"],"content":" Recap Is Python an interpreted language? Python is considered an interpreted language because its reference implementation, CPython, compiles Python code into bytecode at runtime before interpreting it. Is Python a dynamically typed language? Python is a dynamically typed language because it allows variables to be reassigned to values of different types. Is Python a strongly typed language? Python is considered a strongly typed language because most type changes require explicit conversions. Is Python’s static type system nominally or structurally typed? Python’s static type system is generally nominally typed, but collections.abc provides a collection of useful structural types, and typing.Protocol provides a way to define custom structural types. Is Python a duck typed language? Python’s runtime type system is duck typed because it determines type compatibility by checking only the parts of an object’s structure that are accessed at runtime. ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:7:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#recap"},{"categories":["Python"],"content":" Sources[1] Wikipedia: Interpreter (computing) [2] StackOverflow: Compiled vs. Interpreted Languages - Answer by mikera [3] Wikipedia: CPython [4] StackOverflow: Is Python strongly typed? - Answer by community wiki [5] Wikipedia: Strong and weak typing [6] Wikipedia: Nominal type system [7] Wikipedia: Structural type system [8] Wikipedia: Duck typing ","date":"2023-08-17","objectID":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/:8:0","series":null,"tags":["Python","Typing","Programming Languages"],"title":"Python: A Strongly, Dynamically, Duck Typed, Interpreted Language","uri":"/01-python-a-strongly-dynamically-duck-typed-interpreted-language/#sources"},{"categories":null,"content":" Matthew Hoffman ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"","uri":"/about/#matthew-hoffman"},{"categories":null,"content":" What I doI am a research engineer at Protopia AI. At the moment I work almost exclusively in Python, mostly on our PyTorch SDK and model training framework. I’ve also worked on a real-time face recognition pipeline. You can check out my resume if you’d like to learn more about what I’ve worked on. I enjoy design, problem solving, and the creative process. I tend to understand and build things from the bottom up. I am a talented debugger and a passionate advocate for Python typing and my favorite static type analysis tool, pyright. Outside of work, I enjoy taking long walks around San Francisco, trying new restaurants and cafes, and identifying plants. ","date":"0001-01-01","objectID":"/about/:1:0","series":null,"tags":null,"title":"","uri":"/about/#what-i-do"},{"categories":null,"content":" What is this blog?My goal for this blog is to share my knowledge with other Python enthusiasts looking to improve the code they write and the way they develop. I hope this blog can be something you find useful on your own Python journey. ","date":"0001-01-01","objectID":"/about/:2:0","series":null,"tags":null,"title":"","uri":"/about/#what-is-this-blog"}]